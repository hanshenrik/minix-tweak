Separate lists of commonly requested sizes

This is an algorithm first described by Charles B. Weinstock in his Ph.D. dissertation on storage allocation.  He measured the performance of this algorithm.  It has stunning performance.

The idea here is that you keep a "cache" of free blocks of storage rooted in their sizes.  Sizes at this level are always multiples of some basic allocation granularity, such as DWORD.  Like most algorithms that work well, it is based on patterns of observed behavior.  The L1 and L2 caches rely on what is called "locality of reference" to in effect prefetch and cache data that is very likely to be used in the near future.  LRU page replacement is based on the fact that a page which hasn't been used in a long time is unlikely to be used in the near future.  Working set is based on the fact that, like caches, the pages you used most recently are likely to be the pages you are most likely to use in the future.  QuickFit is based on the observed premise that most programs allocate only a small number of discrete sizes of objects.  You might allocate and free objects of type A hundreds of times a second, but you will actually be doing this a lot. 

QuickFit relies on lazy coalescing.  If you free a block of size n, you are very likely, in the near future, to allocate a block of size n, because what you really did was free an object of type A (sizeof(A) == n) and you are therefore fairly likely in the near future to allocate a new object of type A.   So instead of returning the block to the general heap, and possibly coalescing it with nearby blocks, you just hang onto it, keeping it in a list of blocks of size n.  The next time you allocate an object of size n, the allocator looks on the free list[n] to see if there are any blocks laying aroud to be reallocated, and if one is, your allocation is essentially instantaneous.  Only if the list is empty do you revert to one of the slower algorithms.

In QuickFit, coalescing is done before you decide to ask the operating system for more storage.  First you run a coalesce pass, then see if you now have a big enough block.  If you don't, then you get more space from the system.

Note that QuickFit, unlike FirstFit and BestFit, tends to minimize gratuitous memory fragmentation, which improves overall system performance.


// TODO
(1)